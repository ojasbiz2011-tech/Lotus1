<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dense Wood Escape</title>
    
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body { margin: 0; padding: 0; background-color: rgb(250, 242, 230); font-family: 'Verdana', sans-serif; overflow: hidden; user-select: none; }
        
        /* AD OVERLAY STYLE */
        #ad-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95); z-index: 9999;
            flex-direction: column; align-items: center; justify-content: center;
        }
        #ad-wrapper {
            background: #000; border: 2px solid #333;
            box-shadow: 0 0 50px rgba(255, 255, 255, 0.1);
            padding: 10px; border-radius: 4px; margin-bottom: 20px;
            display: flex; align-items: center; justify-content: center;
            min-width: 300px; min-height: 250px; 
        }
        #close-ad-btn {
            background: transparent; color: #fff; border: 1px solid #fff; 
            padding: 12px 40px; font-family: monospace; font-weight: bold; font-size: 14px; 
            border-radius: 30px; cursor: pointer; opacity: 0.3; pointer-events: none; transition: all 0.3s;
        }
        #close-ad-btn.enabled {
            background: #00ff00; color: black; border-color: #00ff00;
            opacity: 1; pointer-events: auto; box-shadow: 0 0 20px #00ff00;
        }

        /* CANVAS & UI */
        canvas { touch-action: none; display: block; }
        
        /* HIDDEN UI FOR LEADERBOARD (Optional integration) */
        .screen { display: none; width: 100%; height: 100%; position: absolute; top:0; left:0; }
        .active { display: block; }
    </style>
</head>
<body>

    <div id="ad-overlay">
        <div style="color: #888; margin-bottom: 10px; font-size: 12px; letter-spacing: 2px;">SPONSORED VIDEO</div>
        <div id="ad-wrapper">
            <div style="color:#444; font-size:12px;">Loading Ad...</div>
        </div>
        <button id="close-ad-btn" onclick="finishAd()">WAIT 5s</button>
    </div>

    <div id="screen-game" class="screen active">
        <canvas id="gameCanvas"></canvas>
    </div>

<script>
// --- CONFIGURATION ---
const GRID_SIZE = 6;
const GAP = 3;

// --- LIGHT WOOD THEME ---
const COLOR_BG = "rgb(250, 242, 230)";
const COLOR_FRAME = "rgb(101, 67, 33)";
const COLOR_WELL = "rgb(180, 130, 70)";
const COLOR_RED = "rgb(205, 70, 70)";
const COLOR_H = "rgb(235, 210, 150)";
const COLOR_V = "rgb(210, 180, 130)";
const COLOR_TEXT = "rgb(80, 50, 30)";

// Global Variables
let canvas = document.getElementById("gameCanvas");
let ctx = canvas.getContext("2d");
let SCREEN_WIDTH = window.innerWidth;
let SCREEN_HEIGHT = window.innerHeight;
canvas.width = SCREEN_WIDTH;
canvas.height = SCREEN_HEIGHT;

// Responsive Sizing
let maxW = SCREEN_WIDTH * 0.90;
let maxH = SCREEN_HEIGHT * 0.75;
let tileW = maxW / GRID_SIZE;
let tileH = maxH / GRID_SIZE;
let TILE_SIZE = Math.floor(Math.min(tileW, tileH));
let GRID_OFFSET_X = (SCREEN_WIDTH - (GRID_SIZE * TILE_SIZE)) / 2;
let GRID_OFFSET_Y = (SCREEN_HEIGHT - (GRID_SIZE * TILE_SIZE)) / 2 + 30;

// Game State
let blocks = [];
let selected = null;
let won = false;
let moves = 0;
let dragOffset = {x: 0, y: 0};
let startP = {col: 0, row: 0};
let isGenerating = false;

// --- BLOCK CLASS TRANSLATION ---
class Block {
    constructor(col, row, length, orientation, is_target=false) {
        this.id = Math.random(); // Unique ID for collision checks
        this.col = col;
        this.row = row;
        this.length = length;
        this.orientation = orientation;
        this.is_target = is_target;
        this.initial_pos = {col: col, row: row};
        
        // Rect properties
        if (this.orientation === 'H') {
            this.width = length * TILE_SIZE - (GAP * 2);
            this.height = TILE_SIZE - (GAP * 2);
            this.color = is_target ? COLOR_RED : COLOR_H;
        } else {
            this.width = TILE_SIZE - (GAP * 2);
            this.height = length * TILE_SIZE - (GAP * 2);
            this.color = COLOR_V;
        }
        
        // Current Pixel Position (rect)
        this.rect = {x: 0, y: 0, w: this.width, h: this.height};
        this.updatePixelPos();
    }

    updatePixelPos() {
        this.rect.x = GRID_OFFSET_X + (this.col * TILE_SIZE) + GAP;
        this.rect.y = GRID_OFFSET_Y + (this.row * TILE_SIZE) + GAP;
    }

    draw() {
        // Draw Shadow
        ctx.fillStyle = "rgba(0, 0, 0, 0.16)";
        roundRect(this.rect.x + 4, this.rect.y + 4, this.rect.w, this.rect.h, 6);
        ctx.fill();

        // Draw Main Body
        ctx.fillStyle = this.color;
        roundRect(this.rect.x, this.rect.y, this.rect.w, this.rect.h, 6);
        ctx.fill();

        // 3D Bevels (Lines)
        ctx.lineWidth = 2;
        ctx.strokeStyle = "rgb(255, 255, 255)"; 
        ctx.beginPath();
        ctx.moveTo(this.rect.x + 3, this.rect.y + 2);
        ctx.lineTo(this.rect.x + this.rect.w - 3, this.rect.y + 2);
        ctx.moveTo(this.rect.x + 2, this.rect.y + 3);
        ctx.lineTo(this.rect.x + 2, this.rect.y + this.rect.h - 3);
        ctx.stroke();

        ctx.strokeStyle = "rgb(0, 0, 0)";
        ctx.beginPath();
        ctx.moveTo(this.rect.x + 3, this.rect.y + this.rect.h - 2);
        ctx.lineTo(this.rect.x + this.rect.w - 3, this.rect.y + this.rect.h - 2);
        ctx.moveTo(this.rect.x + this.rect.w - 2, this.rect.y + 3);
        ctx.lineTo(this.rect.x + this.rect.w - 2, this.rect.y + this.rect.h - 3);
        ctx.stroke();
    }
}

// Helper for rounded rects in canvas
function roundRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.roundRect(x, y, w, h, r);
}

// --- LOGIC ENGINE TRANSLATION ---

function checkGridCollision(c, r, b, allBlocks) {
    if (c < 0 || r < 0) return true;
    
    // Self cells
    let cells = [];
    if (b.orientation === 'H') {
        if (c + b.length > GRID_SIZE) return true;
        for(let i=0; i<b.length; i++) cells.push((c+i) + "," + r);
    } else {
        if (r + b.length > GRID_SIZE) return true;
        for(let i=0; i<b.length; i++) cells.push(c + "," + (r+i));
    }

    // Check against others
    for (let o of allBlocks) {
        if (o.id === b.id) continue;
        let oCells = [];
        for(let i=0; i<o.length; i++) {
            if(o.orientation === 'H') oCells.push((o.col+i) + "," + o.row);
            else oCells.push(o.col + "," + (o.row+i));
        }
        
        // Intersection check
        for(let cell of cells) {
            if(oCells.includes(cell)) return true;
        }
    }
    return false;
}

function checkPixelCollision(rect, activeB, allBlocks) {
    // Boundaries
    if (rect.x < GRID_OFFSET_X) return true;
    if (rect.x + rect.w > GRID_OFFSET_X + (GRID_SIZE * TILE_SIZE)) return true;
    if (rect.y < GRID_OFFSET_Y) return true;
    if (rect.y + rect.h > GRID_OFFSET_Y + (GRID_SIZE * TILE_SIZE)) return true;

    // Collisions with blocks
    // Inflate logic: we basically check if rects overlap slightly
    for (let o of allBlocks) {
        if (o.id === activeB.id) continue;
        
        // Simple AABB Collision
        if (rect.x < o.rect.x + o.rect.w - 2 &&
            rect.x + rect.w > o.rect.x + 2 &&
            rect.y < o.rect.y + o.rect.h - 2 &&
            rect.y + rect.h > o.rect.y + 2) {
                return true;
        }
    }
    return false;
}

// --- SOLVER (BFS) ---
function solveBoard(simBlocks) {
    // Clone blocks for simulation
    let sim = simBlocks.map(b => ({
        col: b.col, row: b.row, length: b.length, 
        orientation: b.orientation, is_target: b.is_target, id: b.id
    }));
    
    let targetIdx = sim.findIndex(b => b.is_target);
    
    // State is a string key of positions "c,r|c,r|..."
    let startState = sim.map(b => b.col + "," + b.row).join("|");
    let queue = [{state: startState, depth: 0}];
    let visited = new Set([startState]);
    let maxDepth = 40; // Limit for performance

    while(queue.length > 0) {
        let current = queue.shift();
        if(current.depth > maxDepth) return -1;

        // Apply state positions to sim array
        let positions = current.state.split("|");
        for(let i=0; i<sim.length; i++) {
            let p = positions[i].split(",");
            sim[i].col = parseInt(p[0]);
            sim[i].row = parseInt(p[1]);
        }

        // Check Win
        if(sim[targetIdx].col === GRID_SIZE - 2) return current.depth;

        // Generate Moves
        for(let i=0; i<sim.length; i++) {
            let b = sim[i];
            let moves = b.orientation === 'H' ? [[-1,0], [1,0]] : [[0,-1], [0,1]];
            
            for(let m of moves) {
                if(!checkGridCollision(b.col + m[0], b.row + m[1], b, sim)) {
                    // Make new state string
                    let newPositions = [...positions];
                    newPositions[i] = (b.col + m[0]) + "," + (b.row + m[1]);
                    let newState = newPositions.join("|");
                    
                    if(!visited.has(newState)) {
                        visited.add(newState);
                        queue.push({state: newState, depth: current.depth + 1});
                    }
                }
            }
        }
    }
    return -1;
}

// --- GAME LOOP ---

function startNewGame() {
    isGenerating = true;
    render(); // Draw loading text immediately

    // Delay 10ms to let browser render the text, then calculate
    setTimeout(() => {
        let tempBlocks = [];
        let startTime = Date.now();
        
        while(true) {
            // Safety break for 1.5s limit
            if (Date.now() - startTime > 1500 && tempBlocks.length > 5) break; 

            tempBlocks = [new Block(Math.random() < 0.5 ? 0 : 1, 2, 2, 'H', true)];
            let targetCount = Math.floor(Math.random() * (19 - 14) + 14); // 14-18
            let fails = 0;

            while(tempBlocks.length < targetCount && fails < 50) {
                let l = Math.random() < 0.6 ? 2 : 3;
                let o = Math.random() < 0.5 ? 'H' : 'V';
                let c, r;
                
                if(o === 'H') {
                    c = Math.floor(Math.random() * (GRID_SIZE - l + 1));
                    r = Math.floor(Math.random() * GRID_SIZE);
                } else {
                    c = Math.floor(Math.random() * GRID_SIZE);
                    r = Math.floor(Math.random() * (GRID_SIZE - l + 1));
                }

                if(r === 2 && o === 'H') { fails++; continue; }

                let nb = new Block(c, r, l, o);
                // Check collision using tempBlocks (needs partial logic)
                if(!checkGridCollision(c, r, nb, tempBlocks)) {
                    tempBlocks.push(nb);
                } else {
                    fails++;
                }
            }

            if(tempBlocks.length >= 13) {
                let result = solveBoard(tempBlocks);
                if(result >= 10) {
                    blocks = tempBlocks;
                    won = false;
                    moves = 0;
                    break;
                }
            }
        }
        isGenerating = false;
        render(); // Re-draw with blocks
    }, 50);
}

// --- RENDERING ---
function render() {
    // Clear
    ctx.fillStyle = COLOR_BG;
    ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

    // Draw Frame
    let frameX = GRID_OFFSET_X - 20;
    let frameY = GRID_OFFSET_Y - 20;
    let frameW = GRID_SIZE * TILE_SIZE + 40;
    let frameH = GRID_SIZE * TILE_SIZE + 40;

    ctx.fillStyle = COLOR_FRAME;
    roundRect(frameX, frameY, frameW, frameH, 12);
    ctx.fill();

    // Well
    ctx.fillStyle = COLOR_WELL;
    roundRect(frameX+15, frameY+15, frameW-30, frameH-30, 4);
    ctx.fill();

    // Exit
    ctx.fillStyle = "black";
    ctx.fillRect(frameX + frameW - 25, GRID_OFFSET_Y + 2 * TILE_SIZE + 5, 30, TILE_SIZE - 10);

    // If generating, show text
    if(isGenerating) {
        ctx.fillStyle = COLOR_FRAME;
        ctx.font = "bold 40px Verdana";
        ctx.textAlign = "center";
        ctx.fillText("Generating...", SCREEN_WIDTH/2, SCREEN_HEIGHT/2);
        ctx.textAlign = "left";
        return;
    }

    // Draw Blocks
    for(let b of blocks) b.draw();

    // Draw UI Text
    ctx.fillStyle = won ? "rgb(0, 150, 0)" : COLOR_TEXT;
    ctx.font = "bold 40px Verdana";
    ctx.textAlign = "center";
    if(won) {
        ctx.fillText("SOLVED!", SCREEN_WIDTH/2, 80);
    } else {
        ctx.font = "18px Verdana";
        ctx.fillText(`Moves: ${moves}  |  'N' for New Puzzle`, SCREEN_WIDTH/2, 100);
    }
    ctx.textAlign = "left";
}

// --- INPUT HANDLING ---
function handleStart(x, y) {
    if(won) return;
    for(let b of blocks) {
        if(x >= b.rect.x && x <= b.rect.x + b.rect.w && y >= b.rect.y && y <= b.rect.y + b.rect.h) {
            selected = b;
            dragOffset.x = b.rect.x - x;
            dragOffset.y = b.rect.y - y;
            startP = {col: b.col, row: b.row};
            break;
        }
    }
}

function handleMove(x, y) {
    if(!selected) return;
    
    // Pixel Perfect Logic from Python
    let sb = selected;
    let targetX = x + dragOffset.x;
    let targetY = y + dragOffset.y;

    if (sb.orientation === 'H') {
        let direction = targetX > sb.rect.x ? 1 : -1;
        let dist = Math.abs(targetX - sb.rect.x);
        for(let i=0; i<dist; i++) {
            let testRect = { ...sb.rect, x: sb.rect.x + direction };
            if(!checkPixelCollision(testRect, sb, blocks)) {
                sb.rect.x += direction;
            } else break;
        }
    } else {
        let direction = targetY > sb.rect.y ? 1 : -1;
        let dist = Math.abs(targetY - sb.rect.y);
        for(let i=0; i<dist; i++) {
            let testRect = { ...sb.rect, y: sb.rect.y + direction };
            if(!checkPixelCollision(testRect, sb, blocks)) {
                sb.rect.y += direction;
            } else break;
        }
    }
    render(); // Redraw on every move
}

function handleEnd() {
    if(!selected) return;
    let sb = selected;

    // Snap to grid logic
    let idealCol = Math.round((sb.rect.x - GRID_OFFSET_X) / TILE_SIZE);
    let idealRow = Math.round((sb.rect.y - GRID_OFFSET_Y) / TILE_SIZE);

    if(sb.orientation === 'H') idealRow = sb.row;
    else idealCol = sb.col;

    if(!checkGridCollision(idealCol, idealRow, sb, blocks)) {
        sb.col = idealCol;
        sb.row = idealRow;
    } else {
        // Snap back if invalid
        // (Or implement the partial step-back logic if desired, but Python code mostly snaps)
        // Revert to startP if collision check fails on drop? 
        // Python code updates pixel pos based on col/row at end.
    }

    sb.updatePixelPos(); // Snap visual to grid
    
    if(sb.col !== startP.col || sb.row !== startP.row) {
        moves++;
        if(sb.is_target && sb.col === 4) won = true;
    }
    selected = null;
    render();
}

// Listeners
canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
canvas.addEventListener('mouseup', handleEnd);
canvas.addEventListener('touchstart', e => { e.preventDefault(); handleStart(e.touches[0].clientX, e.touches[0].clientY); }, {passive: false});
canvas.addEventListener('touchmove', e => { e.preventDefault(); handleMove(e.touches[0].clientX, e.touches[0].clientY); }, {passive: false});
canvas.addEventListener('touchend', handleEnd);

// Keyboard 'N'
document.addEventListener('keydown', (e) => {
    if(e.key.toLowerCase() === 'n') watchAd(); 
});

// --- ADS & INIT ---
function watchAd() {
    document.getElementById('ad-overlay').style.display = 'flex';
    // START GENERATION WHILE AD PLAYS
    // We run startNewGame inside a timeout after ad finishes or during?
    // User requested: "Generate level while user is watching ad"
    // Since JS is single-threaded, we can't block the ad timer.
    // The startNewGame function uses setTimeout/intervals so it won't freeze the timer.
    
    // We delay the generation slightly to ensure overlay renders
    setTimeout(() => {
        startNewGame(); 
    }, 100);

    let timeLeft = 5;
    let btn = document.getElementById('close-ad-btn');
    btn.innerText = `WAIT ${timeLeft}s`;
    btn.classList.remove('enabled');
    let timer = setInterval(() => {
        timeLeft--;
        if(timeLeft <= 0) {
            clearInterval(timer);
            btn.innerText = "âŒ CLOSE & PLAY";
            btn.classList.add('enabled');
        } else {
            btn.innerText = `WAIT ${timeLeft}s`;
        }
    }, 1000);
}

async function finishAd() {
    document.getElementById('ad-overlay').style.display = 'none';
    // Sync with server for money (keep this fetch)
    const userId = window.Telegram?.WebApp?.initDataUnsafe?.user?.id || 12345;
    await fetch('/api/ads/confirm', { method:'POST', body:JSON.stringify({user_id:userId}) });
}

// Initial Start
watchAd();

</script>
</body>
</html>
