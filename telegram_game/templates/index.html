<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dense Wood Escape</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body { margin: 0; padding: 0; background-color: rgb(250, 242, 230); font-family: 'Verdana', sans-serif; overflow: hidden; user-select: none; }
        .screen { display: none; width: 100%; height: 100vh; position: absolute; top: 0; left: 0; flex-direction: column; align-items: center; justify-content: flex-start; padding-top: 20px; }
        .active { display: flex; }
        
        /* UI ELEMENTS */
        h1 { color: rgb(80, 50, 30); margin-bottom: 5px; font-size: 22px; font-weight: bold; }
        .btn { background: rgb(101, 67, 33); color: white; padding: 12px 25px; border-radius: 8px; font-weight: bold; margin: 5px; cursor: pointer; border: 2px solid rgb(80, 50, 30); font-size: 16px; }
        .btn-small { padding: 8px 15px; font-size: 14px; margin: 0 5px; }
        .card { background: rgb(250, 242, 230); border: 3px solid rgb(101, 67, 33); padding: 15px; border-radius: 12px; width: 85%; text-align: center; margin-bottom: 10px; color: rgb(80, 50, 30); box-shadow: 0 4px 0 rgba(101,67,33,0.2); }
        
        /* SCROLLING LOG */
        .log-box { height: 80px; overflow-y: auto; font-size: 12px; text-align: left; background: rgba(0,0,0,0.05); border-radius: 5px; padding: 5px; margin-top: 5px; }
        .log-item { padding: 2px 0; border-bottom: 1px dashed #ccc; }
        
        /* LEADERBOARD */
        .lb-row { display: flex; justify-content: space-between; font-size: 14px; padding: 4px 0; }
        
        canvas { background-color: transparent; touch-action: none; margin-top: 10px; }
    </style>
</head>
<body>

    <div id="screen-home" class="screen active" style="justify-content: center;">
        <h1>Dense Wood Escape</h1>
        
        <div class="card">
            <h3>üèÜ Weekly Prize Pool</h3>
            <h2 style="color: rgb(0, 150, 0); font-size: 32px;" id="pool-display">...</h2>
            
            <div class="log-box" id="activity-log">
                <div class="log-item">Loading activity...</div>
            </div>
        </div>

        <div class="card" style="display: flex; justify-content: space-around;">
            <div>
                <div style="font-size:12px">YOUR RANK</div>
                <div style="font-size:20px; font-weight:bold" id="my-rank">-</div>
            </div>
            <div>
                <div style="font-size:12px">SCORE</div>
                <div style="font-size:20px; font-weight:bold" id="my-score">0</div>
            </div>
        </div>

        <button class="btn" onclick="checkAdsAndPlay()" style="width: 80%;">‚ñ∂ PLAY GAME</button>
        <button class="btn" onclick="showScreen('screen-leaderboard')" style="width: 80%; background: #d4af37; color: black;">üèÖ LEADERBOARD</button>
    </div>

    <div id="screen-leaderboard" class="screen" style="justify-content: center;">
        <h1>Top Players</h1>
        <div class="card" id="lb-list">
            </div>
        <button class="btn" onclick="showScreen('screen-home')">‚¨Ö Back to Home</button>
    </div>

    <div id="screen-game" class="screen">
        <div style="width: 100%; display: flex; justify-content: space-between; padding: 0 15px; box-sizing: border-box; position: absolute; top: 10px;">
            <button class="btn btn-small" onclick="showScreen('screen-home')">üè† Home</button>
            <button class="btn btn-small" style="background: rgb(205, 70, 70);" onclick="showScreen('screen-ads')">Skip ></button>
        </div>
        
        <canvas id="gameCanvas"></canvas>
        
        <div style="position: absolute; bottom: 20px; font-weight: bold; color: rgb(80, 50, 30);">
            MOVES: <span id="move-count">0</span>
        </div>
    </div>

    <div id="screen-ads" class="screen" style="justify-content: center;">
        <div class="card">
            <h1>Skip Level?</h1>
            <p>Watch Ad to get a new puzzle + Add to Pool.</p>
            <button class="btn" onclick="watchAd()">üì∫ Watch Ad</button>
            <br><br>
            <button class="btn btn-small" onclick="showScreen('screen-game')" style="background: #888;">Cancel</button>
        </div>
    </div>

    <script>
        const tg = window.Telegram.WebApp;
        tg.expand();
        
        // AUTH: Get Telegram Data
        const user = tg.initDataUnsafe?.user || {};
        const userId = user.id || 12345;
        const firstName = user.first_name || "Guest";

        // --- GAME VARIABLES ---
        const GRID_SIZE = 6;
        const GAP = 3; 
        const C_BG = "rgb(250, 242, 230)";
        const C_FRAME = "rgb(101, 67, 33)";
        const C_WELL = "rgb(180, 130, 70)";
        const C_RED = "rgb(205, 70, 70)";
        const C_H = "rgb(235, 210, 150)";
        const C_V = "rgb(210, 180, 130)";
        
        let canvas = document.getElementById("gameCanvas");
        let ctx = canvas.getContext("2d");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        let maxW = window.innerWidth * 0.90; 
        let tileW = maxW / GRID_SIZE;
        let TILE_SIZE = Math.floor(tileW);
        let GRID_OFFSET_X = (canvas.width - (GRID_SIZE * TILE_SIZE)) / 2;
        let GRID_OFFSET_Y = (canvas.height - (GRID_SIZE * TILE_SIZE)) / 2; // Centered

        let gameState = { blocks: [], moves: 0, won: false };
        let selectedBlock = null;
        let dragOffset = { x:0, y:0 };

        // --- NAVIGATION ---
        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
            if(id === 'screen-home') loadUserData();
            if(id === 'screen-game') requestAnimationFrame(gameLoop);
        }

        // --- API CALLS ---
        async function loadUserData() { 
            try { 
                let res = await fetch(`/api/user/${userId}`); 
                let d = await res.json(); 
                
                // 1. Update Pool
                document.getElementById('pool-display').innerText = "‚Çπ" + d.global_pool.toFixed(2); 
                
                // 2. Update My Stats
                document.getElementById('my-rank').innerText = "#" + d.rank;
                document.getElementById('my-score').innerText = d.ads_watched;
                
                // 3. Update Activity Log
                let logHTML = "";
                d.recent_logs.forEach(log => {
                    logHTML += `<div class="log-item">üîî ${log}</div>`;
                });
                document.getElementById('activity-log').innerHTML = logHTML || "<div class='log-item'>No recent activity</div>";

                // 4. Update Leaderboard
                let lbHTML = "";
                d.top_players.forEach((p, index) => {
                    let icon = index === 0 ? "ü•á" : (index === 1 ? "ü•à" : "üë§");
                    lbHTML += `<div class="lb-row"><span>${icon} ${p.name}</span><b>${p.ads_watched}</b></div>`;
                });
                document.getElementById('lb-list').innerHTML = lbHTML;

            } catch(e) { console.error(e); } 
        }

        async function startGame() {
            showScreen('screen-game');
            gameState.blocks = []; 
            // "Loading" text
            ctx.fillStyle = "black"; ctx.fillText("Loading Level...", 50, 100);
            
            let res = await fetch('/api/generate_level');
            let levelData = await res.json();
            
            gameState.blocks = levelData.map((b, i) => ({
                id: i, col: b.col, row: b.row, initialCol: b.col, initialRow: b.row, length: b.length, orientation: b.orientation, is_target: b.is_target,
                rect: calculateRect(b.col, b.row, b.length, b.orientation),
                startCol: b.col, startRow: b.row
            }));
            gameState.moves = 0; 
            gameState.won = false;
            document.getElementById('move-count').innerText = 0;
        }

        function watchAd() { 
            let btn = document.querySelector('#screen-ads button');
            btn.innerText = "‚è≥ Verifying...";
            setTimeout(async()=>{ 
                await fetch('/api/ads/confirm', {
                    method:'POST', 
                    body:JSON.stringify({user_id: userId, first_name: firstName})
                }); 
                btn.innerText = "üì∫ Watch Ad";
                startGame(); 
            }, 1000); 
        }

        function checkAdsAndPlay() { startGame(); }

        // --- GAME ENGINE (Visuals) ---
        function calculateRect(col, row, length, orientation) {
            let w = orientation === 'H' ? length * TILE_SIZE - (GAP * 2) : TILE_SIZE - (GAP * 2);
            let h = orientation === 'V' ? length * TILE_SIZE - (GAP * 2) : TILE_SIZE - (GAP * 2);
            let x = GRID_OFFSET_X + (col * TILE_SIZE) + GAP;
            let y = GRID_OFFSET_Y + (row * TILE_SIZE) + GAP;
            return { x, y, w, h };
        }

        function drawBlock(b) {
            let color = b.is_target ? C_RED : (b.orientation === 'H' ? C_H : C_V);
            let { x, y, w, h } = b.rect;
            ctx.fillStyle = color; ctx.beginPath(); ctx.roundRect(x, y, w, h, 6); ctx.fill();
            // Simple Borders
            ctx.strokeStyle = "rgba(0,0,0,0.3)"; ctx.lineWidth = 2; ctx.stroke();
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw Board Frame
            let frameSize = GRID_SIZE * TILE_SIZE + 20;
            ctx.fillStyle = C_FRAME; 
            ctx.fillRect(GRID_OFFSET_X - 10, GRID_OFFSET_Y - 10, frameSize, frameSize);
            ctx.fillStyle = C_WELL; 
            ctx.fillRect(GRID_OFFSET_X, GRID_OFFSET_Y, GRID_SIZE * TILE_SIZE, GRID_SIZE * TILE_SIZE);
            
            // Exit Hole
            ctx.fillStyle = "black"; 
            ctx.fillRect(GRID_OFFSET_X + (GRID_SIZE * TILE_SIZE), GRID_OFFSET_Y + (2 * TILE_SIZE) + 5, 20, TILE_SIZE - 10);

            gameState.blocks.forEach(drawBlock);
            
            if(gameState.won) {
                ctx.fillStyle = "rgba(0,0,0,0.7)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "#00ff00"; ctx.font = "bold 40px Arial"; ctx.fillText("SOLVED!", canvas.width/2 - 80, canvas.height/2);
            }

            if(document.getElementById('screen-game').classList.contains('active')) { requestAnimationFrame(gameLoop); }
        }

        // --- INPUT HANDLING ---
        function handleStart(x, y) {
            if(gameState.won) return;
            for(let b of gameState.blocks) {
                if(x >= b.rect.x && x <= b.rect.x + b.rect.w && y >= b.rect.y && y <= b.rect.y + b.rect.h) {
                    selectedBlock = b; dragOffset.x = b.rect.x - x; dragOffset.y = b.rect.y - y;
                    b.startCol = b.col; b.startRow = b.row; break;
                }
            }
        }
        function handleMove(x, y) {
            if(!selectedBlock) return;
            let sb = selectedBlock; let targetX = x + dragOffset.x; let targetY = y + dragOffset.y;
            if (sb.orientation === 'H') {
                let direction = targetX > sb.rect.x ? 1 : -1; let dist = Math.abs(targetX - sb.rect.x);
                for(let i=0; i<dist; i++) { let testRect = { ...sb.rect, x: sb.rect.x + direction }; if (!checkCollisionVisual(testRect, sb)) sb.rect.x += direction; else break; }
            } else {
                let direction = targetY > sb.rect.y ? 1 : -1; let dist = Math.abs(targetY - sb.rect.y);
                for(let i=0; i<dist; i++) { let testRect = { ...sb.rect, y: sb.rect.y + direction }; if (!checkCollisionVisual(testRect, sb)) sb.rect.y += direction; else break; }
            }
        }
        function handleEnd() {
            if(!selectedBlock) return;
            let sb = selectedBlock;
            let idealCol = Math.round((sb.rect.x - GRID_OFFSET_X) / TILE_SIZE); let idealRow = Math.round((sb.rect.y - GRID_OFFSET_Y) / TILE_SIZE);
            if(sb.orientation === 'H') idealRow = sb.row; else idealCol = sb.col;
            if(!checkCollisionGrid(idealCol, idealRow, sb, gameState.blocks)) { sb.col = idealCol; sb.row = idealRow; } else { sb.col = sb.startCol; sb.row = sb.startRow; }
            sb.rect = calculateRect(sb.col, sb.row, sb.length, sb.orientation);
            if(sb.col !== sb.startCol || sb.row !== sb.startRow) {
                gameState.moves++; document.getElementById('move-count').innerText = gameState.moves;
                if(sb.is_target && sb.col === 4) { gameState.won = true; submitGame(); }
            }
            selectedBlock = null;
        }
        
        // --- HELPERS ---
        function checkCollisionVisual(rect, activeB) {
            if (rect.x < GRID_OFFSET_X) return true; if (rect.x + rect.w > GRID_OFFSET_X + (GRID_SIZE * TILE_SIZE)) return true;
            if (rect.y < GRID_OFFSET_Y) return true; if (rect.y + rect.h > GRID_OFFSET_Y + (GRID_SIZE * TILE_SIZE)) return true;
            let hitbox = { x: rect.x+2, y: rect.y+2, w: rect.w-4, h: rect.h-4 };
            for(let o of gameState.blocks) {
                if (o.id === activeB.id) continue;
                let oHit = { x: o.rect.x+2, y: o.rect.y+2, w: o.rect.w-4, h: o.rect.h-4 };
                if (hitbox.x < oHit.x + oHit.w && hitbox.x + hitbox.w > oHit.x && hitbox.y < oHit.y + oHit.h && hitbox.y + hitbox.h > oHit.y) return true;
            }
            return false;
        }
        function checkCollisionGrid(c, r, b, allBlocks) {
             if (c < 0 || r < 0) return true; if (b.orientation === 'H' && c + b.length > GRID_SIZE) return true; if (b.orientation === 'V' && r + b.length > GRID_SIZE) return true;
             let cells = []; for(let i=0; i<b.length; i++) cells.push(b.orientation === 'H' ? `${c+i},${r}` : `${c},${r+i}`);
             for(let o of allBlocks) {
                 if(o.id === b.id) continue;
                 for(let j=0; j<o.length; j++) { let ox = o.col + (o.orientation==='H'?j:0); let oy = o.row + (o.orientation==='V'?j:0); if(cells.includes(`${ox},${oy}`)) return true; }
             }
             return false;
        }
        async function submitGame() { await fetch('/api/submit_game', { method: 'POST', body: JSON.stringify({ user_id: userId }) }); }

        // Event Listeners
        canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
        canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('touchstart', e => { e.preventDefault(); handleStart(e.touches[0].clientX, e.touches[0].clientY); }, {passive: false});
        canvas.addEventListener('touchmove', e => { e.preventDefault(); handleMove(e.touches[0].clientX, e.touches[0].clientY); }, {passive: false});
        canvas.addEventListener('touchend', handleEnd);
        
        // Start on Load
        loadUserData();
    </script>
</body>
</html>
