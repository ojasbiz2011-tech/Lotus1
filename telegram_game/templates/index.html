<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dense Wood Escape</title>
    
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body { margin: 0; padding: 0; background-color: rgb(250, 242, 230); font-family: 'Verdana', sans-serif; overflow: hidden; user-select: none; }
        
        /* SCREENS & NAVIGATION */
        .screen { display: none; width: 100%; height: 100vh; position: absolute; top: 0; left: 0; flex-direction: column; align-items: center; justify-content: flex-start; padding-top: 20px; box-sizing: border-box; }
        .active { display: flex; }

        /* UI ELEMENTS */
        h1 { color: rgb(80, 50, 30); margin-bottom: 5px; font-size: 24px; font-weight: bold; text-align: center; }
        
        .card { 
            background: rgb(250, 242, 230); border: 4px solid rgb(101, 67, 33); 
            padding: 15px; border-radius: 12px; width: 85%; text-align: center; 
            margin-bottom: 10px; color: rgb(80, 50, 30); 
            box-shadow: 0 4px 0 rgba(101,67,33,0.2); 
        }

        .btn { 
            background: rgb(101, 67, 33); color: white; padding: 15px 30px; 
            border-radius: 8px; font-weight: bold; margin: 5px; cursor: pointer; 
            border: 2px solid rgb(80, 50, 30); box-shadow: 0 4px 6px rgba(0,0,0,0.3); 
            font-size: 16px; width: 80%;
        }
        .btn-gold { background: #d4af37; color: black; border-color: #b8962e; }
        .btn-red { background: rgb(205, 70, 70); border-color: rgb(150, 50, 50); }
        .btn-small { width: auto; padding: 8px 15px; font-size: 14px; margin: 0; }

        /* GAME HEADER */
        .game-header {
            width: 100%; display: flex; justify-content: space-between; 
            padding: 10px 25px; 
            position: absolute; top: 0; left: 0; z-index: 100;
            box-sizing: border-box;
        }

        /* LOGS & LEADERBOARD */
        .log-box { 
            height: 80px; overflow-y: auto; font-size: 12px; text-align: left; 
            background: rgba(101, 67, 33, 0.05); border: 2px solid rgb(101, 67, 33); 
            border-radius: 8px; padding: 5px; margin-top: 10px; 
        }
        .log-item { padding: 3px 0; border-bottom: 1px dashed rgb(101, 67, 33); color: rgb(80, 50, 30); }
        .lb-list { height: 60vh; overflow-y: auto; text-align: left; }
        .lb-row { display: flex; justify-content: space-between; padding: 8px; border-bottom: 1px solid rgba(101,67,33,0.3); }

        canvas { touch-action: none; display: block; }
    </style>
</head>
<body>

    <div id="screen-home" class="screen active">
        <h1>Dense Wood Escape</h1>
        <div class="card">
            <h3>üèÜ Weekly Prize Pool</h3>
            <h2 id="pool-display">‚Çπ0.00</h2>
            <div class="log-box" id="activity-log"><div class="log-item">Loading...</div></div>
        </div>
        <div class="card" style="padding: 10px;">
            <div style="display: flex; justify-content: space-around;">
                <div><span style="font-size:10px;">YOUR RANK</span><br><b style="font-size:20px;" id="my-rank">-</b></div>
                <div><span style="font-size:10px;">SCORE</span><br><b style="font-size:20px;" id="my-score">0</b></div>
            </div>
        </div>
        <button class="btn" onclick="watchAd()">‚ñ∂ Play Puzzle</button>
        <button class="btn btn-gold" onclick="showScreen('screen-leaderboard')">üèÖ Leaderboard</button>
    </div>

    <div id="screen-leaderboard" class="screen">
        <h1>Top Players</h1>
        <div class="card lb-list" id="lb-content"><div>Loading...</div></div>
        <button class="btn" onclick="showScreen('screen-home')">‚¨Ö Back Home</button>
    </div>

    <div id="screen-game" class="screen">
        <div class="game-header">
            <button class="btn btn-small" onclick="exitGame()">‚ùå Exit</button>
            <button class="btn btn-small btn-red" onclick="watchAd()">New Level ></button>
        </div>
        <canvas id="gameCanvas"></canvas>
    </div>

<script>
// --- 4x4 REVOLUTION CONFIGURATION ---
const GRID_SIZE = 4; // Changed from 6 to 4 for density
const GAP = 2; // Tighter gaps

// --- THEME ---
const COLOR_BG = "rgb(250, 242, 230)";
const COLOR_FRAME = "rgb(101, 67, 33)";
const COLOR_WELL = "rgb(180, 130, 70)";
const COLOR_RED = "rgb(205, 70, 70)";
const COLOR_H = "rgb(235, 210, 150)";
const COLOR_V = "rgb(210, 180, 130)";
const COLOR_TEXT = "rgb(80, 50, 30)";

// Canvas Variables
let canvas = document.getElementById("gameCanvas");
let ctx = canvas.getContext("2d");
let SCREEN_WIDTH, SCREEN_HEIGHT, TILE_SIZE, GRID_OFFSET_X, GRID_OFFSET_Y;

// Game State
let blocks = [];
let selected = null;
let won = false;
let moves = 0;
let dragOffset = {x: 0, y: 0};
let startP = {col: 0, row: 0};
let isGenerating = false; // "Generating..." flag
let activeTouchId = null; 

// --- RESIZE HANDLER ---
function resizeCanvas() {
    SCREEN_WIDTH = window.innerWidth;
    SCREEN_HEIGHT = window.innerHeight;
    canvas.width = SCREEN_WIDTH;
    canvas.height = SCREEN_HEIGHT;

    // Make board larger on screen (90% width)
    let maxW = SCREEN_WIDTH * 0.90;
    let maxH = SCREEN_HEIGHT * 0.70;
    let tileW = maxW / GRID_SIZE;
    let tileH = maxH / GRID_SIZE;
    TILE_SIZE = Math.floor(Math.min(tileW, tileH));
    
    // Center the grid
    GRID_OFFSET_X = (SCREEN_WIDTH - (GRID_SIZE * TILE_SIZE)) / 2;
    GRID_OFFSET_Y = (SCREEN_HEIGHT - (GRID_SIZE * TILE_SIZE)) / 2 + 30;

    if(blocks.length > 0) blocks.forEach(b => b.updatePixelPos());
    requestAnimationFrame(render);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas(); 

// --- UI NAV ---
function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
    if(id === 'screen-home') loadUserData();
    if(id === 'screen-game') { resizeCanvas(); requestAnimationFrame(render); }
}

function exitGame() { showScreen('screen-home'); }

async function loadUserData() {
    try {
        const userId = window.Telegram?.WebApp?.initDataUnsafe?.user?.id || 12345;
        let res = await fetch(`/api/user/${userId}`);
        if(res.ok) {
            let d = await res.json();
            document.getElementById('pool-display').innerText = "‚Çπ" + d.global_pool.toFixed(2);
            document.getElementById('my-rank').innerText = "#" + d.rank;
            document.getElementById('my-score').innerText = d.ads_watched;
            let logHTML = ""; d.recent_logs.forEach(l => logHTML += `<div class="log-item">üîî ${l}</div>`);
            document.getElementById('activity-log').innerHTML = logHTML || "<div class='log-item'>No recent activity</div>";
            let lbHTML = ""; d.top_players.forEach((p, i) => {
                let icon = i===0 ? "ü•á" : (i===1 ? "ü•à" : (i===2 ? "ü•â" : "üë§"));
                lbHTML += `<div class="lb-row"><span>${icon} ${p.name}</span><b>${p.ads_watched}</b></div>`;
            });
            document.getElementById('lb-content').innerHTML = lbHTML || "<div>No players yet</div>";
        }
    } catch(e) {}
}

// --- BLOCK CLASS (Dense 1x2 Logic) ---
class Block {
    constructor(col, row, length, orientation, is_target=false) {
        this.id = Math.random(); 
        this.col = col; this.row = row; this.length = length;
        this.orientation = orientation; this.is_target = is_target;
        this.updatePixelPos();
        // Colors
        if(is_target) this.color = COLOR_RED;
        else this.color = (orientation === 'H') ? COLOR_H : COLOR_V;
    }

    updatePixelPos() {
        if (this.orientation === 'H') {
            this.width = this.length * TILE_SIZE - (GAP * 2);
            this.height = TILE_SIZE - (GAP * 2);
        } else {
            this.width = TILE_SIZE - (GAP * 2);
            this.height = this.length * TILE_SIZE - (GAP * 2);
        }
        this.rect = {
            x: GRID_OFFSET_X + (this.col * TILE_SIZE) + GAP,
            y: GRID_OFFSET_Y + (this.row * TILE_SIZE) + GAP,
            w: this.width,
            h: this.height
        };
    }

    draw() {
        // Shadow
        ctx.fillStyle = "rgba(0,0,0,0.15)";
        roundRect(this.rect.x + 3, this.rect.y + 3, this.rect.w, this.rect.h, 6);
        ctx.fill();
        // Body
        ctx.fillStyle = this.color;
        roundRect(this.rect.x, this.rect.y, this.rect.w, this.rect.h, 6);
        ctx.fill();
        // Bevels
        ctx.lineWidth = 2;
        ctx.strokeStyle = "rgba(255,255,255,0.6)"; 
        ctx.beginPath(); ctx.moveTo(this.rect.x+2, this.rect.y+this.rect.h-2); 
        ctx.lineTo(this.rect.x+2, this.rect.y+2); ctx.lineTo(this.rect.x+this.rect.w-2, this.rect.y+2); ctx.stroke();
        ctx.strokeStyle = "rgba(0,0,0,0.3)"; 
        ctx.beginPath(); ctx.moveTo(this.rect.x+2, this.rect.y+this.rect.h-2);
        ctx.lineTo(this.rect.x+this.rect.w-2, this.rect.y+this.rect.h-2); ctx.lineTo(this.rect.x+this.rect.w-2, this.rect.y+2); ctx.stroke();
    }
}
function roundRect(x, y, w, h, r) { ctx.beginPath(); ctx.roundRect(x, y, w, h, r); }

// --- COLLISION LOGIC ---
function checkCollision(c, r, b, allBlocks) {
    if(c < 0 || r < 0) return true;
    if(b.orientation === 'H') {
        if(c + b.length > GRID_SIZE) return true;
        // Check overlap
        for(let other of allBlocks) {
            if(other.id === b.id) continue;
            // AABB Collision on Grid Coords
            if(c < other.col + (other.orientation==='H'?other.length:1) && c + b.length > other.col &&
               r < other.row + (other.orientation==='V'?other.length:1) && r + 1 > other.row) return true;
        }
    } else {
        if(r + b.length > GRID_SIZE) return true;
        for(let other of allBlocks) {
            if(other.id === b.id) continue;
            if(c < other.col + (other.orientation==='H'?other.length:1) && c + 1 > other.col &&
               r < other.row + (other.orientation==='V'?other.length:1) && r + b.length > other.row) return true;
        }
    }
    return false;
}

// --- NEW GENERATOR: REVERSE SHUFFLE (Always Solvable) ---
function startNewGame() {
    isGenerating = true;
    blocks = []; 
    won = false;
    moves = 0;
    
    // 1. Force screen render to show "Generating..."
    render();

    setTimeout(() => {
        // A. Start with a SOLVED board
        // Target (Red) at exit
        let tempBlocks = [ new Block(GRID_SIZE-2, 1, 2, 'H', true) ]; 
        
        // Fill remaining space with 1x2 blocks (Density)
        // Simple filling strategy: just pack them in rows/cols
        for(let r=0; r<GRID_SIZE; r++) {
            for(let c=0; c<GRID_SIZE; c++) {
                // Skip if occupied
                if(checkCollision(c, r, {col:c, row:r, length:1, orientation:'H', id:-1}, tempBlocks)) continue;
                
                // Try Horizontal
                if(Math.random() > 0.5 && !checkCollision(c, r, {col:c, row:r, length:2, orientation:'H', id:-1}, tempBlocks)) {
                    tempBlocks.push(new Block(c, r, 2, 'H'));
                }
                // Try Vertical
                else if(!checkCollision(c, r, {col:c, row:r, length:2, orientation:'V', id:-1}, tempBlocks)) {
                    tempBlocks.push(new Block(c, r, 2, 'V'));
                }
            }
        }

        // B. SCRAMBLE IT (Reverse Shuffle)
        // Make 150 random valid moves
        for(let i=0; i<150; i++) {
            let movable = [];
            // Find all blocks that can move
            for(let b of tempBlocks) {
                // Check Left/Right or Up/Down
                if(b.orientation === 'H') {
                    if(!checkCollision(b.col-1, b.row, b, tempBlocks)) movable.push({b:b, d:-1});
                    if(!checkCollision(b.col+1, b.row, b, tempBlocks)) movable.push({b:b, d:1});
                } else {
                    if(!checkCollision(b.col, b.row-1, b, tempBlocks)) movable.push({b:b, d:-1});
                    if(!checkCollision(b.col, b.row+1, b, tempBlocks)) movable.push({b:b, d:1});
                }
            }
            if(movable.length > 0) {
                let move = movable[Math.floor(Math.random() * movable.length)];
                if(move.b.orientation === 'H') move.b.col += move.d;
                else move.b.row += move.d;
            }
        }

        // C. Update final positions
        tempBlocks.forEach(b => b.updatePixelPos());
        blocks = tempBlocks;
        
        isGenerating = false;
        render(); // Final draw
    }, 100);
}

// --- RENDER LOOP ---
function render() {
    if(!document.getElementById('screen-game').classList.contains('active')) return;

    // 1. Clear Screen
    ctx.fillStyle = COLOR_BG; ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
    
    // 2. Draw Frame (4x4)
    let frameX = GRID_OFFSET_X - 15; let frameY = GRID_OFFSET_Y - 15;
    let frameW = GRID_SIZE * TILE_SIZE + 30; let frameH = GRID_SIZE * TILE_SIZE + 30;
    
    ctx.fillStyle = COLOR_FRAME; roundRect(frameX, frameY, frameW, frameH, 12); ctx.fill();
    ctx.fillStyle = COLOR_WELL; roundRect(frameX+10, frameY+10, frameW-20, frameH-20, 4); ctx.fill();
    
    // Exit Hole (Right side, Row 1)
    ctx.fillStyle = "black"; 
    ctx.fillRect(frameX + frameW - 20, GRID_OFFSET_Y + (1 * TILE_SIZE) + GAP, 25, TILE_SIZE - (GAP*2));

    // 3. Draw "Generating..." if flag is set
    if(isGenerating) {
        ctx.fillStyle = COLOR_FRAME; 
        ctx.font = "bold 24px Verdana"; 
        ctx.textAlign = "center";
        ctx.fillText("Generating Puzzle...", SCREEN_WIDTH/2, SCREEN_HEIGHT/2); 
        ctx.textAlign = "left"; 
        return; // Stop drawing blocks
    }

    // 4. Draw Blocks
    for(let b of blocks) b.draw();

    // 5. Draw UI Text
    ctx.fillStyle = won ? "rgb(0, 150, 0)" : COLOR_TEXT;
    ctx.font = "bold 24px Verdana"; ctx.textAlign = "center";
    if(won) ctx.fillText("ESCAPED!", SCREEN_WIDTH/2, 100);
    else { ctx.font = "18px Verdana"; ctx.fillText(`Moves: ${moves}`, SCREEN_WIDTH/2, 100); }
    ctx.textAlign = "left";
    
    requestAnimationFrame(render);
}

// --- INPUTS (Fix for Neighbor Bug: getBoundingClientRect) ---
function getTouchPos(eX, eY) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: eX - rect.left,
        y: eY - rect.top
    };
}

function handleStart(rawX, rawY) {
    if(won || isGenerating) return;
    let pos = getTouchPos(rawX, rawY); // Correct coordinate mapping
    
    for(let b of blocks) {
        if(pos.x >= b.rect.x && pos.x <= b.rect.x + b.rect.w && 
           pos.y >= b.rect.y && pos.y <= b.rect.y + b.rect.h) {
            selected = b; 
            dragOffset.x = b.rect.x - pos.x; 
            dragOffset.y = b.rect.y - pos.y;
            startP = {col: b.col, row: b.row}; 
            break;
        }
    }
}

function handleMove(rawX, rawY) {
    if(!selected) return;
    let pos = getTouchPos(rawX, rawY);
    let sb = selected; 
    let targetX = pos.x + dragOffset.x; 
    let targetY = pos.y + dragOffset.y;

    // Constrain to grid axis
    if (sb.orientation === 'H') {
        let direction = targetX > sb.rect.x ? 1 : -1; 
        let dist = Math.abs(targetX - sb.rect.x);
        for(let i=0; i<dist; i++) {
            // Check 1px step
            sb.rect.x += direction;
            if(checkPixelCollision(sb)) { sb.rect.x -= direction; break; }
        }
    } else {
        let direction = targetY > sb.rect.y ? 1 : -1; 
        let dist = Math.abs(targetY - sb.rect.y);
        for(let i=0; i<dist; i++) {
            sb.rect.y += direction;
            if(checkPixelCollision(sb)) { sb.rect.y -= direction; break; }
        }
    }
}

function checkPixelCollision(sb) {
    // Bounds
    if(sb.rect.x < GRID_OFFSET_X || sb.rect.x + sb.rect.w > GRID_OFFSET_X + (GRID_SIZE*TILE_SIZE)) return true;
    if(sb.rect.y < GRID_OFFSET_Y || sb.rect.y + sb.rect.h > GRID_OFFSET_Y + (GRID_SIZE*TILE_SIZE)) return true;
    
    // Other blocks (Simple AABB with slight shrinkage for smooth sliding)
    let margin = 2;
    for(let o of blocks) {
        if(o.id === sb.id) continue;
        if (sb.rect.x < o.rect.x + o.rect.w - margin && sb.rect.x + sb.rect.w > o.rect.x + margin &&
            sb.rect.y < o.rect.y + o.rect.h - margin && sb.rect.y + sb.rect.h > o.rect.y + margin) return true;
    }
    return false;
}

function handleEnd() {
    if(!selected) return;
    let sb = selected;
    // Snap to grid
    let idealCol = Math.round((sb.rect.x - GRID_OFFSET_X) / TILE_SIZE);
    let idealRow = Math.round((sb.rect.y - GRID_OFFSET_Y) / TILE_SIZE);
    
    // Constraint check
    if(sb.orientation === 'H') idealRow = sb.row; else idealCol = sb.col;
    
    if(!checkCollision(idealCol, idealRow, sb, blocks)) {
        sb.col = idealCol; sb.row = idealRow;
    }
    sb.updatePixelPos(); // Snap visual
    
    if(sb.col !== startP.col || sb.row !== startP.row) {
        moves++;
        // Win Condition: Red block at edge (Col 2 for 4x4 grid means index 2+length 2 = 4)
        if(sb.is_target && sb.col === GRID_SIZE - 2) won = true;
    }
    selected = null;
    activeTouchId = null;
}

// Touch Listeners
canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
canvas.addEventListener('mouseup', handleEnd);

canvas.addEventListener('touchstart', e => { 
    e.preventDefault(); 
    if(activeTouchId !== null) return;
    activeTouchId = e.changedTouches[0].identifier;
    handleStart(e.changedTouches[0].clientX, e.changedTouches[0].clientY); 
}, {passive: false});

canvas.addEventListener('touchmove', e => { 
    e.preventDefault(); 
    for(let i=0; i<e.changedTouches.length; i++) {
        if(e.changedTouches[i].identifier === activeTouchId) {
            handleMove(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
        }
    }
}, {passive: false});

canvas.addEventListener('touchend', e => {
    for(let i=0; i<e.changedTouches.length; i++) {
        if(e.changedTouches[i].identifier === activeTouchId) handleEnd();
    }
});

// --- ADS & INIT ---
async function recordAdReward() {
    try {
        const userId = window.Telegram?.WebApp?.initDataUnsafe?.user?.id || 12345;
        await fetch('/api/ads/confirm', { method:'POST', body:JSON.stringify({user_id:userId}) });
        loadUserData(); 
    } catch(e) {}
}

function watchAd() {
    if (typeof show_10572322 === 'function') {
        show_10572322().then(() => {
            console.log("Ad success");
            showScreen('screen-game'); // Switch Screen
            startNewGame(); 
            recordAdReward();
        }).catch(e => {
            console.log("Ad failed:", e);
            showScreen('screen-game'); 
            startNewGame();
        });
    } else {
        console.log("Ad script missing");
        showScreen('screen-game');
        startNewGame();
    }
}
</script>
</body>
</html>
