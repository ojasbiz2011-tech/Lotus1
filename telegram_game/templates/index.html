<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dense Wood Escape</title>

    <script src='//libtl.com/sdk.js' data-zone='10572322' data-sdk='show_10572322'></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body { margin: 0; padding: 0; background-color: rgb(250, 242, 230); font-family: 'Verdana', sans-serif; overflow: hidden; user-select: none; }
        
        /* SCREENS & NAVIGATION */
        .screen { display: none; width: 100%; height: 100vh; position: absolute; top: 0; left: 0; flex-direction: column; align-items: center; justify-content: flex-start; padding-top: 20px; box-sizing: border-box; }
        .active { display: flex; }

        /* UI ELEMENTS */
        h1 { color: rgb(80, 50, 30); margin-bottom: 5px; font-size: 24px; font-weight: bold; text-align: center; }
        
        .card { 
            background: rgb(250, 242, 230); border: 4px solid rgb(101, 67, 33); 
            padding: 15px; border-radius: 12px; width: 85%; text-align: center; 
            margin-bottom: 10px; color: rgb(80, 50, 30); 
            box-shadow: 0 4px 0 rgba(101,67,33,0.2); 
        }

        .btn { 
            background: rgb(101, 67, 33); color: white; padding: 15px 30px; 
            border-radius: 8px; font-weight: bold; margin: 5px; cursor: pointer; 
            border: 2px solid rgb(80, 50, 30); box-shadow: 0 4px 6px rgba(0,0,0,0.3); 
            font-size: 16px; width: 80%;
        }
        .btn-gold { background: #d4af37; color: black; border-color: #b8962e; }
        .btn-red { background: rgb(205, 70, 70); border-color: rgb(150, 50, 50); }
        .btn-small { width: auto; padding: 8px 15px; font-size: 14px; margin: 0; }

        /* GAME HEADER */
        .game-header {
            width: 100%; display: flex; justify-content: space-between; 
            padding: 10px 25px; 
            position: absolute; top: 0; left: 0; z-index: 100;
            box-sizing: border-box;
        }

        /* LOGS & LEADERBOARD */
        .log-box { 
            height: 80px; overflow-y: auto; font-size: 12px; text-align: left; 
            background: rgba(101, 67, 33, 0.05); border: 2px solid rgb(101, 67, 33); 
            border-radius: 8px; padding: 5px; margin-top: 10px; 
        }
        .log-item { padding: 3px 0; border-bottom: 1px dashed rgb(101, 67, 33); color: rgb(80, 50, 30); }
        .lb-list { height: 60vh; overflow-y: auto; text-align: left; }
        .lb-row { display: flex; justify-content: space-between; padding: 8px; border-bottom: 1px solid rgba(101,67,33,0.3); }

        canvas { touch-action: none; display: block; }
    </style>
</head>
<body>

    <div id="screen-home" class="screen active">
        <h1>Dense Wood Escape</h1>
        <div class="card">
            <h3>üèÜ Weekly Prize Pool</h3>
            <h2 id="pool-display">‚Çπ0.00</h2>
            <div class="log-box" id="activity-log"><div class="log-item">Loading...</div></div>
        </div>
        <div class="card" style="padding: 10px;">
            <div style="display: flex; justify-content: space-around;">
                <div><span style="font-size:10px;">YOUR RANK</span><br><b style="font-size:20px;" id="my-rank">-</b></div>
                <div><span style="font-size:10px;">SCORE</span><br><b style="font-size:20px;" id="my-score">0</b></div>
            </div>
        </div>
        <button class="btn" onclick="watchAd()">‚ñ∂ Play Puzzle</button>
        <button class="btn btn-gold" onclick="showScreen('screen-leaderboard')">üèÖ Leaderboard</button>
    </div>

    <div id="screen-leaderboard" class="screen">
        <h1>Top Players</h1>
        <div class="card lb-list" id="lb-content"><div>Loading...</div></div>
        <button class="btn" onclick="showScreen('screen-home')">‚¨Ö Back Home</button>
    </div>

    <div id="screen-game" class="screen">
        <div class="game-header">
            <button class="btn btn-small" onclick="exitGame()">‚ùå Exit</button>
            <button class="btn btn-small btn-red" onclick="watchAd()">New Level ></button>
        </div>
        <canvas id="gameCanvas"></canvas>
    </div>

<script>
// --- CONFIGURATION ---
const GRID_SIZE = 6;
const GAP = 3;

// --- THEME ---
const COLOR_BG = "rgb(250, 242, 230)";
const COLOR_FRAME = "rgb(101, 67, 33)";
const COLOR_WELL = "rgb(180, 130, 70)";
const COLOR_RED = "rgb(205, 70, 70)";
const COLOR_H = "rgb(235, 210, 150)";
const COLOR_V = "rgb(210, 180, 130)";
const COLOR_TEXT = "rgb(80, 50, 30)";

// Canvas Variables
let canvas = document.getElementById("gameCanvas");
let ctx = canvas.getContext("2d");
let SCREEN_WIDTH, SCREEN_HEIGHT, TILE_SIZE, GRID_OFFSET_X, GRID_OFFSET_Y;

// Game State
let blocks = [];
let selected = null;
let won = false;
let moves = 0;
let dragOffset = {x: 0, y: 0};
let startP = {col: 0, row: 0};
let isGenerating = false; 
let activeTouchId = null; 

// --- RESIZE HANDLER ---
function resizeCanvas() {
    SCREEN_WIDTH = window.innerWidth;
    SCREEN_HEIGHT = window.innerHeight;
    canvas.width = SCREEN_WIDTH;
    canvas.height = SCREEN_HEIGHT;

    let maxW = SCREEN_WIDTH * 0.90;
    let maxH = SCREEN_HEIGHT * 0.75;
    let tileW = maxW / GRID_SIZE;
    let tileH = maxH / GRID_SIZE;
    TILE_SIZE = Math.floor(Math.min(tileW, tileH));
    
    GRID_OFFSET_X = (SCREEN_WIDTH - (GRID_SIZE * TILE_SIZE)) / 2;
    GRID_OFFSET_Y = (SCREEN_HEIGHT - (GRID_SIZE * TILE_SIZE)) / 2 + 30;

    if(blocks.length > 0) blocks.forEach(b => b.updatePixelPos());
    requestAnimationFrame(render);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas(); 

// --- UI NAV ---
function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
    if(id === 'screen-home') loadUserData();
    if(id === 'screen-game') { resizeCanvas(); requestAnimationFrame(render); }
}

function exitGame() { showScreen('screen-home'); }

async function loadUserData() {
    try {
        const userId = window.Telegram?.WebApp?.initDataUnsafe?.user?.id || 12345;
        let res = await fetch(`/api/user/${userId}`);
        if(res.ok) {
            let d = await res.json();
            document.getElementById('pool-display').innerText = "‚Çπ" + d.global_pool.toFixed(2);
            document.getElementById('my-rank').innerText = "#" + d.rank;
            document.getElementById('my-score').innerText = d.ads_watched;
            let logHTML = ""; d.recent_logs.forEach(l => logHTML += `<div class="log-item">üîî ${l}</div>`);
            document.getElementById('activity-log').innerHTML = logHTML || "<div class='log-item'>No recent activity</div>";
            let lbHTML = ""; d.top_players.forEach((p, i) => {
                let icon = i===0 ? "ü•á" : (i===1 ? "ü•à" : (i===2 ? "ü•â" : "üë§"));
                lbHTML += `<div class="lb-row"><span>${icon} ${p.name}</span><b>${p.ads_watched}</b></div>`;
            });
            document.getElementById('lb-content').innerHTML = lbHTML || "<div>No players yet</div>";
        }
    } catch(e) {}
}

// --- BLOCK CLASS ---
class Block {
    constructor(col, row, length, orientation, is_target=false) {
        this.id = Math.random(); 
        this.col = col; this.row = row; this.length = length;
        this.orientation = orientation; this.is_target = is_target;
        this.updatePixelPos();
        
        if (this.orientation === 'H') {
            this.color = is_target ? COLOR_RED : COLOR_H;
        } else {
            this.color = COLOR_V;
        }
    }

    updatePixelPos() {
        if (this.orientation === 'H') {
            this.width = this.length * TILE_SIZE - (GAP * 2);
            this.height = TILE_SIZE - (GAP * 2);
        } else {
            this.width = TILE_SIZE - (GAP * 2);
            this.height = this.length * TILE_SIZE - (GAP * 2);
        }
        this.rect = {
            x: GRID_OFFSET_X + (this.col * TILE_SIZE) + GAP,
            y: GRID_OFFSET_Y + (this.row * TILE_SIZE) + GAP,
            w: this.width,
            h: this.height
        };
    }

    draw() {
        // Shadow
        ctx.fillStyle = "rgba(0, 0, 0, 0.16)";
        roundRect(this.rect.x + 4, this.rect.y + 4, this.rect.w, this.rect.h, 6);
        ctx.fill();
        // Body
        ctx.fillStyle = this.color;
        roundRect(this.rect.x, this.rect.y, this.rect.w, this.rect.h, 6);
        ctx.fill();
        // Bevels
        ctx.lineWidth = 2;
        ctx.strokeStyle = "rgb(255, 255, 255)"; 
        ctx.beginPath(); ctx.moveTo(this.rect.x+3, this.rect.y+2); ctx.lineTo(this.rect.x+this.rect.w-3, this.rect.y+2);
        ctx.moveTo(this.rect.x+2, this.rect.y+3); ctx.lineTo(this.rect.x+2, this.rect.y+this.rect.h-3); ctx.stroke();
        ctx.strokeStyle = "rgb(0, 0, 0)";
        ctx.beginPath(); ctx.moveTo(this.rect.x+3, this.rect.y+this.rect.h-2); ctx.lineTo(this.rect.x+this.rect.w-3, this.rect.y+this.rect.h-2);
        ctx.moveTo(this.rect.x+this.rect.w-2, this.rect.y+3); ctx.lineTo(this.rect.x+this.rect.w-2, this.rect.y+this.rect.h-3); ctx.stroke();
    }
}
function roundRect(x, y, w, h, r) { ctx.beginPath(); ctx.roundRect(x, y, w, h, r); }

// --- COLLISION ---
function checkGridCollision(c, r, b, allBlocks) {
    if (c < 0 || r < 0) return true;
    let cells = [];
    if (b.orientation === 'H') {
        if (c + b.length > GRID_SIZE) return true;
        for(let i=0; i<b.length; i++) cells.push((c+i) + "," + r);
    } else {
        if (r + b.length > GRID_SIZE) return true;
        for(let i=0; i<b.length; i++) cells.push(c + "," + (r+i));
    }
    for (let o of allBlocks) {
        if (o.id === b.id) continue;
        let oCells = [];
        for(let i=0; i<o.length; i++) {
            if(o.orientation === 'H') oCells.push((o.col+i) + "," + o.row);
            else oCells.push(o.col + "," + (o.row+i));
        }
        for(let cell of cells) if(oCells.includes(cell)) return true;
    }
    return false;
}

function checkPixelCollision(rect, activeB, allBlocks) {
    if (rect.x < GRID_OFFSET_X) return true;
    if (rect.x + rect.w > GRID_OFFSET_X + (GRID_SIZE * TILE_SIZE)) return true;
    if (rect.y < GRID_OFFSET_Y) return true;
    if (rect.y + rect.h > GRID_OFFSET_Y + (GRID_SIZE * TILE_SIZE)) return true;
    for (let o of allBlocks) {
        if (o.id === activeB.id) continue;
        if (rect.x < o.rect.x + o.rect.w - 2 && rect.x + rect.w > o.rect.x + 2 &&
            rect.y < o.rect.y + o.rect.h - 2 && rect.y + rect.h > o.rect.y + 2) return true;
    }
    return false;
}

// --- SOLVER ---
function solveBoard(simBlocks) {
    let sim = simBlocks.map(b => ({ col: b.col, row: b.row, length: b.length, orientation: b.orientation, is_target: b.is_target, id: b.id }));
    let targetIdx = sim.findIndex(b => b.is_target);
    let startState = sim.map(b => b.col + "," + b.row).join("|");
    let queue = [{state: startState, depth: 0}];
    let visited = new Set([startState]);
    let maxDepth = 40; 

    while(queue.length > 0) {
        let current = queue.shift();
        if(current.depth > maxDepth) return -1;
        let positions = current.state.split("|");
        for(let i=0; i<sim.length; i++) { let p = positions[i].split(","); sim[i].col = parseInt(p[0]); sim[i].row = parseInt(p[1]); }
        if(sim[targetIdx].col === GRID_SIZE - 2) return current.depth;

        for(let i=0; i<sim.length; i++) {
            let b = sim[i];
            let moves = b.orientation === 'H' ? [[-1,0], [1,0]] : [[0,-1], [0,1]];
            for(let m of moves) {
                if(!checkGridCollision(b.col + m[0], b.row + m[1], b, sim)) {
                    let newPositions = [...positions];
                    newPositions[i] = (b.col + m[0]) + "," + (b.row + m[1]);
                    let newState = newPositions.join("|");
                    if(!visited.has(newState)) { visited.add(newState); queue.push({state: newState, depth: current.depth + 1}); }
                }
            }
        }
    }
    return -1;
}

// --- GENERATION ---
function startNewGame() {
    isGenerating = true;
    blocks = []; 
    render(); 
    setTimeout(() => {
        let tempBlocks = [];
        let startTime = Date.now();
        while(true) {
            if (Date.now() - startTime > 1500 && tempBlocks.length > 5) break; 
            tempBlocks = [new Block(Math.random() < 0.5 ? 0 : 1, 2, 2, 'H', true)];
            let targetCount = Math.floor(Math.random() * (19 - 14) + 14); 
            let fails = 0;
            while(tempBlocks.length < targetCount && fails < 50) {
                let l = Math.random() < 0.6 ? 2 : 3;
                let o = Math.random() < 0.5 ? 'H' : 'V';
                let c, r;
                if(o === 'H') { c = Math.floor(Math.random() * (GRID_SIZE - l + 1)); r = Math.floor(Math.random() * GRID_SIZE); } 
                else { c = Math.floor(Math.random() * GRID_SIZE); r = Math.floor(Math.random() * (GRID_SIZE - l + 1)); }
                if(r === 2 && o === 'H') { fails++; continue; }
                let nb = new Block(c, r, l, o);
                if(!checkGridCollision(c, r, nb, tempBlocks)) tempBlocks.push(nb); else fails++;
            }
            if(tempBlocks.length >= 13) {
                let result = solveBoard(tempBlocks);
                if(result >= 10) { blocks = tempBlocks; won = false; moves = 0; break; }
            }
        }
        isGenerating = false;
        render(); 
    }, 50);
}

// --- RENDER LOOP ---
function render() {
    if(!document.getElementById('screen-game').classList.contains('active')) return;

    ctx.fillStyle = COLOR_BG; ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
    
    let frameX = GRID_OFFSET_X - 20; let frameY = GRID_OFFSET_Y - 20;
    let frameW = GRID_SIZE * TILE_SIZE + 40; let frameH = GRID_SIZE * TILE_SIZE + 40;
    ctx.fillStyle = COLOR_FRAME; roundRect(frameX, frameY, frameW, frameH, 12); ctx.fill();
    ctx.fillStyle = COLOR_WELL; roundRect(frameX+15, frameY+15, frameW-30, frameH-30, 4); ctx.fill();
    ctx.fillStyle = "black"; ctx.fillRect(frameX + frameW - 25, GRID_OFFSET_Y + 2 * TILE_SIZE + 5, 30, TILE_SIZE - 10);

    if(isGenerating || blocks.length === 0) {
        ctx.fillStyle = COLOR_FRAME; ctx.font = "bold 30px Verdana"; ctx.textAlign = "center";
        ctx.fillText("Generating...", SCREEN_WIDTH/2, SCREEN_HEIGHT/2); 
        ctx.textAlign = "left"; 
        requestAnimationFrame(render);
        return;
    }

    for(let b of blocks) b.draw();

    ctx.fillStyle = won ? "rgb(0, 150, 0)" : COLOR_TEXT;
    ctx.font = "bold 24px Verdana"; ctx.textAlign = "center";
    if(won) ctx.fillText("SOLVED!", SCREEN_WIDTH/2, 100);
    else { ctx.font = "18px Verdana"; ctx.fillText(`Moves: ${moves}`, SCREEN_WIDTH/2, 100); }
    ctx.textAlign = "left";
    
    requestAnimationFrame(render);
}

// --- INPUTS (FIXED: Uses getBoundingClientRect for correct coords) ---
function getTouchPos(eX, eY) {
    let rect = canvas.getBoundingClientRect();
    return {
        x: eX - rect.left,
        y: eY - rect.top
    };
}

function handleStart(rawX, rawY) {
    if(won || isGenerating) return;
    if(selected) return; // Prevent multi-touch overriding
    
    let pos = getTouchPos(rawX, rawY);
    
    for(let b of blocks) {
        if(pos.x >= b.rect.x && pos.x <= b.rect.x + b.rect.w && 
           pos.y >= b.rect.y && pos.y <= b.rect.y + b.rect.h) {
            selected = b; 
            dragOffset.x = b.rect.x - pos.x; 
            dragOffset.y = b.rect.y - pos.y;
            startP = {col: b.col, row: b.row}; 
            break;
        }
    }
}

function handleMove(rawX, rawY) {
    if(!selected) return;
    let pos = getTouchPos(rawX, rawY);
    let sb = selected; 
    let targetX = pos.x + dragOffset.x; 
    let targetY = pos.y + dragOffset.y;

    if (sb.orientation === 'H') {
        let direction = targetX > sb.rect.x ? 1 : -1; 
        let dist = Math.abs(targetX - sb.rect.x);
        for(let i=0; i<dist; i++) {
            let testRect = { ...sb.rect, x: sb.rect.x + direction };
            if(!checkPixelCollision(testRect, sb, blocks)) sb.rect.x += direction; else break;
        }
    } else {
        let direction = targetY > sb.rect.y ? 1 : -1; 
        let dist = Math.abs(targetY - sb.rect.y);
        for(let i=0; i<dist; i++) {
            let testRect = { ...sb.rect, y: sb.rect.y + direction };
            if(!checkPixelCollision(testRect, sb, blocks)) sb.rect.y += direction; else break;
        }
    }
}

function handleEnd() {
    if(!selected) return;
    let sb = selected;
    let idealCol = Math.round((sb.rect.x - GRID_OFFSET_X) / TILE_SIZE);
    let idealRow = Math.round((sb.rect.y - GRID_OFFSET_Y) / TILE_SIZE);
    
    if(sb.orientation === 'H') idealRow = sb.row; else idealCol = sb.col;
    
    if(!checkGridCollision(idealCol, idealRow, sb, blocks)) {
        sb.col = idealCol; sb.row = idealRow;
    }
    sb.updatePixelPos();
    
    if(sb.col !== startP.col || sb.row !== startP.row) {
        moves++;
        if(sb.is_target && sb.col === 4) won = true;
    }
    selected = null;
    activeTouchId = null;
}

// Touch Listeners
canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
canvas.addEventListener('mouseup', handleEnd);

canvas.addEventListener('touchstart', e => { 
    e.preventDefault(); 
    if(activeTouchId !== null) return;
    activeTouchId = e.changedTouches[0].identifier;
    handleStart(e.changedTouches[0].clientX, e.changedTouches[0].clientY); 
}, {passive: false});

canvas.addEventListener('touchmove', e => { 
    e.preventDefault(); 
    for(let i=0; i<e.changedTouches.length; i++) {
        if(e.changedTouches[i].identifier === activeTouchId) {
            handleMove(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
        }
    }
}, {passive: false});

canvas.addEventListener('touchend', e => {
    for(let i=0; i<e.changedTouches.length; i++) {
        if(e.changedTouches[i].identifier === activeTouchId) handleEnd();
    }
});

// --- ADS & INIT ---
async function recordAdReward() {
    try {
        const userId = window.Telegram?.WebApp?.initDataUnsafe?.user?.id || 12345;
        await fetch('/api/ads/confirm', { method:'POST', body:JSON.stringify({user_id:userId}) });
        loadUserData(); 
    } catch(e) {}
}

function watchAd() {
    if (typeof show_10572322 === 'function') {
        show_10572322().then(() => {
            console.log("Ad success");
            showScreen('screen-game');
            startNewGame(); 
            recordAdReward();
        }).catch(e => {
            console.log("Ad failed:", e);
            showScreen('screen-game'); 
            startNewGame();
        });
    } else {
        console.log("Ad script missing");
        showScreen('screen-game');
        startNewGame();
    }
}

// Initial Load
loadUserData();
</script>
</body>
</html>
